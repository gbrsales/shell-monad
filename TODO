* setVar allows `Var a` to be set to any value, the value
  is not constrained to be of type `a`. This seems necessary
  to allow, eg, `setVar v (Output (cmd "read"))`. On other
  hand, it's subptimal when using setVar with a Arith; in this
  case `a` should be some Integral.

* Allow: test (n `TEqual` 42)

* Add an instance: Num a => Num (Var a)

  This could make `var1 + var2` yield `APlus var1 var2`. And so ease
  construction of Arith expressions.

  Seems very doable! However, would it also be possible to support `var1 + 1`?
  The 1 would need to be first lifted to some kind of Var. It could be done
  by `one <- newVarContaining 1 ()` and then `var1 + one`. But clumsy..

  What if there were two kinds of Vars, regular Var and Const.
  The Const would always just expand to its constant value. Then
  we could say `var1 + Const 1`.

* Bug: script  $ newVar () >>= \v -> defaultVar v "foo"  >>= \v -> defaultVar v "foo"  >>= \v -> cmd "echo" v
  This generates: "#!/bin/sh\n_v=\necho \"${_v2:-foo}\"\n"
  Which doesn't work, since the temporary variable generated by the
  first defaultVar doesn't expand to anything.

  Fix: Make the temporary variable expand?

  Instead, this should probably use the hack that lengthVar uses.
  That hack nests repeatedly.

* A variable produced using lengthVar cannot be nested inside an arith
  expression. The problem is the double parens used to quote the hacked
  variable. These parens are not allowed inside $(( )).

  It seems that the parens are not necessary here. Compare:

	echo "${_tmp:-"$(_tmp="$_v"; echo "${#_tmp}")"}"
	echo "${_tmp:-$(_tmp=$_v; echo ${#_tmp})}"

  These expand the same even when $_v contains wildcards or whitespace.

